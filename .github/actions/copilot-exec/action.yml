name: copilot-exec
description: |
  Run GitHub Copilot CLI with a rendered prompt template (simplified env-based + caching).

  Features:
  - Automatic caching based on prompt content and model
  - Configurable timeout (default: 30 minutes)
  - Verbose logging for debugging
  - MCP (Model Context Protocol) configuration support
  - Conditional repository checkout (skips if already present)
  - Dependency caching for npm global packages and project node_modules
  - Performance optimizations for faster workflow execution
author: "ralph@nyphon.de"
inputs:
  prompt-path:
    description: Path to the prompt template file
    required: true
  working-directory:
    description: Directory to run the Copilot command in
    required: false
    default: ""
  output-path:
    description: File path (relative to working-directory) to store Copilot output
    required: false
    default: copilot-output.txt
  extra-args:
    description: Additional arguments to append to the Copilot CLI invocation
    required: false
    default: ""
  additional-mcp-config:
    description: Optional MCP configuration JSON or @path to extend Copilot's capabilities
    required: false
    default: ""
  allow-all-paths:
    description: Whether to allow Copilot CLI access to any file path
    required: false
    default: "true"
  model:
    description: Optional model identifier to pass to Copilot CLI. If not provided or empty, no model flag is passed to Copilot CLI.
    required: false
    default: ""
  copilot-token:
    description: API token for GitHub Copilot service (use secrets.COPILOT_TOKEN)
    required: true
  timeout:
    description: Maximum time in minutes for Copilot CLI execution (default 30 minutes)
    required: false
    default: "30"
  verbose:
    description: Enable verbose logging for debugging (true/false, default false)
    required: false
    default: "false"
  force-response:
    description: Skip cache restoration to force fresh Copilot CLI execution (true/false, default false). Useful for time-sensitive data analysis or debugging.
    required: false
    default: "false"

outputs:
  output-path:
    description: Absolute path to the Copilot CLI output file
    value: ${{ steps.cached.outputs.output-path || steps.copilot.outputs.output-path }}

runs:
  using: composite
  steps:
    - name: Detect checkout status
      id: detect-checkout
      shell: bash
      run: |
        set -euo pipefail
        if [ -d .git ]; then
          echo "need-checkout=false" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Repository already present, skipping checkout"
        else
          echo "need-checkout=true" >> "$GITHUB_OUTPUT"
          echo "üîÑ Repository not present, will perform checkout"
        fi
    - name: Conditional checkout
      if: steps.detect-checkout.outputs.need-checkout == 'true'
      uses: actions/checkout@v4
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: "20" # stick to prebuilt sharp targets

    - name: Cache npm global + npm cache
      uses: actions/cache@v4
      with:
        path: |
          ~/.npm/_global
          ~/.npm/_cacache
        key: copilot-cli-${{ runner.os }}-node20-v2-@github/copilot@1.0.0
        restore-keys: |
          copilot-cli-${{ runner.os }}-node20-

    - name: Cache project dependencies
      id: cache-deps
      uses: actions/cache@v4
      with:
        path: |
          node_modules
        key: copilot-deps-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          copilot-deps-${{ runner.os }}-

    # üö´ Remove apt-get entirely unless you *know* you need it
    # sharp will fetch its own prebuilt libvips bundle.

    - name: Install Copilot CLI (npm global)
      shell: bash
      run: |
        set -euo pipefail
        export NPM_CONFIG_PREFIX="$HOME/.npm/_global"
        export PATH="$HOME/.npm/_global/bin:$PATH"
        if command -v copilot >/dev/null 2>&1; then
          echo "‚úÖ Copilot CLI cached"
        else
          npm install -g @github/copilot
        fi
        echo "$HOME/.npm/_global/bin" >> "$GITHUB_PATH"

    - name: Install project dependencies (if package.json present)
      if: steps.cache-deps.outputs.cache-hit != 'true'
      shell: bash
      run: |
        set -euo pipefail
        if [ -f package.json ]; then
          echo "üì¶ Installing project dependencies with Yarn"
          if ! yarn install --frozen-lockfile; then
            echo "‚ö†Ô∏è Frozen lockfile install failed, falling back to regular install"
            yarn install
          fi
        else
          echo "‚ÑπÔ∏è No package.json found, skipping dependency install"
        fi

    - name: Render prompt
      id: render
      if: cancelled() == false
      shell: bash
      env:
        PROMPT_TEMPLATE: ${{ inputs.prompt-path }}
        VERBOSE: ${{ inputs.verbose }}
      run: |
        set -euo pipefail
        start_time=$(date +%s)

        if [ "$VERBOSE" = "true" ]; then
          echo "üîç Rendering prompt template: $PROMPT_TEMPLATE"
        fi

        rendered="$(mktemp)"
        envsubst < "$PROMPT_TEMPLATE" > "$rendered"
        prompt_sha=$(sha256sum "$rendered" | awk '{print $1}')

        echo "prompt-file=$rendered" >> "$GITHUB_OUTPUT"
        echo "prompt-sha=$prompt_sha" >> "$GITHUB_OUTPUT"

        if [ "$VERBOSE" = "true" ]; then
          end_time=$(date +%s)
          elapsed=$((end_time - start_time))
          rendered_size=$(wc -c < "$rendered")
          echo "‚úÖ Prompt rendered in ${elapsed}s (size: ${rendered_size} bytes, sha256: $prompt_sha)"
        fi

    - name: Install jq
      shell: bash
      run: |
        set -euo pipefail
        if ! command -v jq >/dev/null 2>&1; then
          sudo apt-get update -qq && sudo apt-get install -y -qq jq
        fi

    - name: Resolve model configuration
      id: resolve-model
      shell: bash
      env:
        REQUESTED_MODEL: ${{ inputs.model }}
        COPILOT_MODEL: ${{ env.COPILOT_MODEL }}
        VERBOSE: ${{ inputs.verbose }}
      run: |
        set -euo pipefail

        # Priority: 1. Input parameter, 2. COPILOT_MODEL env var, 3. Empty (no default)
        model=""

        if [ -n "${REQUESTED_MODEL:-}" ]; then
          model="$REQUESTED_MODEL"
          echo "‚ÑπÔ∏è  Using model from input parameter: $model"
        elif [ -n "${COPILOT_MODEL:-}" ]; then
          model="$COPILOT_MODEL"
          echo "‚ÑπÔ∏è  Using model from COPILOT_MODEL environment variable: $model"
        else
          echo "‚ÑπÔ∏è  No model specified, will use Copilot CLI default"
        fi

        echo "model=$model" >> "$GITHUB_OUTPUT"

        if [ "$VERBOSE" = "true" ]; then
          echo "‚úÖ Resolved Copilot model: ${model:-<empty>}"
          echo "   - Input parameter: ${REQUESTED_MODEL:-<empty>}"
          echo "   - COPILOT_MODEL env: ${COPILOT_MODEL:-<empty>}"
          echo "   - Final selection: ${model:-<empty>}"
        fi

    - name: Restore result cache
      if: inputs.force-response != 'true'
      id: cache-result
      uses: actions/cache@v4
      with:
        path: .copilot-cache/output.txt
        key: copilot-result-${{ steps.render.outputs.prompt-sha }}-${{ steps.resolve-model.outputs.model }}-${{ runner.os }}

    - name: Log cache status
      if: inputs.verbose == 'true'
      shell: bash
      env:
        CACHE_HIT: ${{ steps.cache-result.outputs.cache-hit }}
        PROMPT_SHA: ${{ steps.render.outputs.prompt-sha }}
        RESOLVED_MODEL: ${{ steps.resolve-model.outputs.model }}
      run: |
        if [ "$CACHE_HIT" = "true" ]; then
          echo "‚úÖ Cache hit for prompt sha256: $PROMPT_SHA (model: $RESOLVED_MODEL)"
        else
          echo "üîÑ Cache miss - will execute Copilot CLI (prompt sha256: $PROMPT_SHA, model: $RESOLVED_MODEL)"
        fi

    - name: Short-circuit if cached
      if: steps.cache-result.outputs.cache-hit == 'true'
      id: cached
      shell: bash
      env:
        WORKDIR: ${{ inputs.working-directory != '' && inputs.working-directory || github.workspace }}
        RAW_OUTPUT_PATH: ${{ inputs.output-path }}
        VERBOSE: ${{ inputs.verbose }}
      run: |
        set -euo pipefail
        out="${RAW_OUTPUT_PATH:-copilot-output.txt}"
        [[ "${out:0:1}" != "/" ]] && out="$WORKDIR/$out"
        mkdir -p "$(dirname "$out")"
        cp .copilot-cache/output.txt "$out"
        echo "output-path=$out" >> "$GITHUB_OUTPUT"

        if [ "$VERBOSE" = "true" ]; then
          cached_size=$(wc -c < "$out")
          echo "‚úÖ Reused cached Copilot output (size: ${cached_size} bytes, path: $out)"
        else
          echo "‚úÖ Reused cached Copilot output"
        fi

    - name: Setup MCP configuration
      if: steps.cache-result.outputs.cache-hit != 'true'
      id: mcp-config
      shell: bash
      env:
        ADDITIONAL_MCP_CONFIG: ${{ inputs.additional-mcp-config }}
        VERBOSE: ${{ inputs.verbose }}
      run: |
        set -euo pipefail
        mcp_config_file="$HOME/.copilot-mcp-config.json"

        if [ "$VERBOSE" = "true" ]; then
          echo "üîß Setting up MCP configuration"
        fi

        # Start with base GitHub MCP server configuration
        cat > "$mcp_config_file" << 'EOF'
        {
          "mcpServers": {
            "github": {
              "command": "npx",
              "args": ["-y", "@modelcontextprotocol/server-github"]
            }
          }
        }
        EOF

        # If additional MCP config is provided, merge it
        if [ -n "$ADDITIONAL_MCP_CONFIG" ]; then
          if [[ "$ADDITIONAL_MCP_CONFIG" == @* ]]; then
            # It's a file path reference (starts with @)
            config_file="${ADDITIONAL_MCP_CONFIG:1}"
            if [ -f "$config_file" ]; then
              echo "üìã Merging MCP config from $config_file"
              # Use jq to merge the configurations
              jq -s '.[0].mcpServers * .[1].mcpServers | {mcpServers: .}' \
                "$mcp_config_file" "$config_file" > "$mcp_config_file.tmp"
              mv "$mcp_config_file.tmp" "$mcp_config_file"
            else
              echo "‚ö†Ô∏è  MCP config file not found: $config_file"
            fi
          else
            # It's inline JSON
            echo "üìã Merging inline MCP config"
            echo "$ADDITIONAL_MCP_CONFIG" > "$mcp_config_file.tmp"
            jq -s '.[0].mcpServers * .[1].mcpServers | {mcpServers: .}' \
              "$mcp_config_file" "$mcp_config_file.tmp" > "$mcp_config_file.merged"
            mv "$mcp_config_file.merged" "$mcp_config_file"
            rm "$mcp_config_file.tmp"
          fi
        fi

        echo "‚úÖ MCP configuration prepared at $mcp_config_file"

        if [ "$VERBOSE" = "true" ]; then
          echo "üìã MCP Configuration:"
          cat "$mcp_config_file" >&2
        fi

        echo "mcp-config-file=$mcp_config_file" >> "$GITHUB_OUTPUT"

    - name: Execute Copilot CLI
      if: steps.cache-result.outputs.cache-hit != 'true'
      id: copilot
      shell: bash
      env:
        WORKDIR: ${{ inputs.working-directory != '' && inputs.working-directory || github.workspace }}
        PROMPT_FILE: ${{ steps.render.outputs.prompt-file }}
        RAW_OUTPUT_PATH: ${{ inputs.output-path }}
        EXTRA_ARGS: ${{ inputs.extra-args }}
        RESOLVED_MODEL: ${{ steps.resolve-model.outputs.model }}
        COPILOT_ALLOW_ALL: "1"
        COPILOT_TELEMETRY_OPTOUT: "1"
        COPILOT_MCP_CONFIG: ${{ steps.mcp-config.outputs.mcp-config-file }}
        VERBOSE: ${{ inputs.verbose }}
        TIMEOUT_MINUTES: ${{ inputs.timeout }}
        GITHUB_TOKEN: ${{ inputs.copilot-token }}
      run: |
        set -euo pipefail
        export PATH="$HOME/.npm/_global/bin:$PATH"
        start_time=$(date +%s)

        out="${RAW_OUTPUT_PATH:-copilot-output.txt}"
        [[ "${out:0:1}" != "/" ]] && out="$WORKDIR/$out"
        mkdir -p "$WORKDIR" "$(dirname "$out")"
        prompt="$(cat "$PROMPT_FILE")"

        cmd=(copilot -p "$prompt" --allow-all-tools --no-color --add-dir "$WORKDIR")
        [ -n "$RESOLVED_MODEL" ] && cmd+=(--model "$RESOLVED_MODEL")
        if [ -n "$EXTRA_ARGS" ]; then read -r -a extra <<< "$EXTRA_ARGS"; cmd+=("${extra[@]}"); fi

        if [ "$VERBOSE" = "true" ]; then
          echo "üöÄ Executing Copilot CLI (timeout: ${TIMEOUT_MINUTES} minutes)"
          echo "   Command: ${cmd[*]}"
          echo "   Working directory: $WORKDIR"
          echo "   Output path: $out"
          echo "   Model: ${RESOLVED_MODEL:-<default>}"
        else
          echo "üöÄ ${cmd[*]}" >&2
        fi

        mkdir -p .copilot-cache
        "${cmd[@]}" | tee .copilot-cache/output.txt > "$out"
        status=${PIPESTATUS[0]}

        if [ "$status" -ne 0 ]; then
          echo "‚ùå Copilot CLI failed with status $status" >&2
          exit "$status"
        fi

        end_time=$(date +%s)
        elapsed=$((end_time - start_time))
        output_size=$(wc -c < "$out")

        echo "output-path=$out" >> "$GITHUB_OUTPUT"

        if [ "$VERBOSE" = "true" ]; then
          echo "‚úÖ Copilot CLI finished successfully"
          echo "   Duration: ${elapsed}s"
          echo "   Output size: ${output_size} bytes"
        else
          echo "‚úÖ Copilot CLI finished"
        fi
