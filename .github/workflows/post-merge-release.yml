name: Post Merge Release

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Python 2
        uses: ./.github/actions/setup-python2

      - name: Setup Node.js 16
        uses: ./.github/actions/setup-node16

      - name: Export Python path for node-gyp
        shell: bash
        run: |
          echo "GYP_DEFINES=standalone_static_library=0" >> $GITHUB_ENV
          echo "PYTHON=$(command -v python2 || command -v python)" >> $GITHUB_ENV
          python --version

      - name: Install dependencies (with Python 2)
        run: npm install

      - name: Lint with fixes
        run: npm run lint:fix

      - name: Format with write
        run: npm run format:write

      - name: Bump version
        id: bump
        shell: bash
        run: |
          VERSION=$(npm run version:bump | tail -n 1)
          if [ -z "$VERSION" ]; then
            echo "Version bump did not return a version"; exit 1
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "RELEASE_BRANCH=release/v$VERSION" >> "$GITHUB_ENV"

      - name: Refresh version index
        run: npm run versions:update

      # ⬇️ Commit to the release branch instead of main
      - name: Commit changes to release branch
        id: commit
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: prepare release ${{ steps.bump.outputs.version }}"
          branch: ${{ env.RELEASE_BRANCH }}
          create_branch: true
          commit_user_name: github-actions[bot]
          commit_user_email: 41898282+github-actions[bot]@users.noreply.github.com
          push_options: --force-with-lease

      # Create tag pointing at the release branch commit (idempotent)
      - name: Create tag
        if: steps.bump.outputs.version != '' && steps.commit.outputs.commit_hash != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const version = '${{ steps.bump.outputs.version }}';
            const sha = '${{ steps.commit.outputs.commit_hash || github.sha }}';

            const getRefPath = `tags/v${version}`;         // correct for getRef
            const createRefPath = `refs/tags/v${version}`;  // correct for createRef

            try {
              await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: getRefPath,
              });
              core.info(`Tag ${createRefPath} already exists`);
            } catch (error) {
              if (error.status !== 404) throw error;
              try {
                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: createRefPath,
                  sha,
                });
                core.info(`Created tag ${createRefPath} at ${sha}`);
              } catch (e) {
                if (e.status === 422 && /Reference already exists/i.test(e.message)) {
                  core.info(`Tag ${createRefPath} already exists (race condition)`);
                } else {
                  throw e;
                }
              }
            }

      # Open or reuse PR from release/vX.Y.Z (aka release/v${version}) into main
      - name: Create release branch and PR for tag
        if: steps.bump.outputs.version != '' && steps.commit.outputs.commit_hash != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const version = '${{ steps.bump.outputs.version }}';
            const tag = `v${version}`;
            const branch = `release/${tag}`;
            const sha = '${{ steps.commit.outputs.commit_hash || github.sha }}';

            // 1) Ensure the branch exists at the tag's commit (idempotent)
            async function ensureBranch() {
              try {
                await github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` });
                core.info(`Branch ${branch} already exists`);
              } catch (err) {
                if (err.status !== 404) throw err;
                await github.rest.git.createRef({
                  owner, repo,
                  ref: `refs/heads/${branch}`,
                  sha
                });
                core.info(`Created branch ${branch} at ${sha}`);
              }
            }

            // 2) Generate release notes (best-effort)
            async function generateNotes() {
              try {
                const { data } = await github.rest.repos.generateReleaseNotes({
                  owner, repo,
                  tag_name: tag,
                  target_commitish: sha
                });
                return data.body || `Release ${tag}`;
              } catch (e) {
                core.warning(`Could not generate notes: ${e.message}`);
                return `Release ${tag}`;
              }
            }

            // 3) Create (or reuse) PR release/<tag> -> main
            async function ensurePullRequest(body) {
              const baseBranch = 'main';
              const headBranch = branch;

              const { data: prs } = await github.rest.pulls.list({
                owner, repo, state: 'open', head: `${owner}:${headBranch}`, base: baseBranch
              });

              if (prs.length > 0) {
                core.info(`PR already exists: #${prs[0].number}`);
                core.setOutput('pr_number', prs[0].number);
                return;
              }

              const { data: pr } = await github.rest.pulls.create({
                owner, repo,
                title: `Release ${tag}`,
                head: headBranch,
                base: baseBranch,
                body
              });
              core.info(`Created PR #${pr.number} for ${headBranch} -> ${baseBranch}`);
              core.setOutput('pr_number', pr.number);
            }

            await ensureBranch();
            const body = await generateNotes();
            await ensurePullRequest(body)
