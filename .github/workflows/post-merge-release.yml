name: Post Merge Release

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest
    # Skip workflow if the commit is a release PR merge (prevents recursive execution)
    if: "!contains(github.event.head_commit.message, 'chore: prepare release')"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Python 2
        uses: ./.github/actions/setup-python2

      - name: Setup Node.js 16
        uses: ./.github/actions/setup-node16

      - name: Export Python path for node-gyp
        shell: bash
        run: |
          echo "GYP_DEFINES=standalone_static_library=0" >> $GITHUB_ENV
          echo "PYTHON=$(command -v python2 || command -v python)" >> $GITHUB_ENV
          python --version

      - name: Install dependencies (with Python 2)
        run: npm install

      - name: Lint with fixes
        run: npm run lint:fix

      - name: Format with write
        run: npm run format:write

      - name: Bump version
        id: bump
        shell: bash
        run: |
          VERSION=$(npm run version:bump | tail -n 1)
          if [ -z "$VERSION" ]; then
            echo "Version bump did not return a version"; exit 1
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "RELEASE_BRANCH=release/v$VERSION" >> "$GITHUB_ENV"

      - name: Refresh version index
        run: npm run versions:update

      # Ensure we have latest refs before committing
      - name: Update remote refs
        run: |
          git fetch origin --prune
          git remote prune origin

      # ⬇️ Commit to the release branch instead of main
      - name: Commit changes to release branch
        id: commit
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: prepare release ${{ steps.bump.outputs.version }}"
          branch: ${{ env.RELEASE_BRANCH }}
          create_branch: true
          commit_user_name: github-actions[bot]
          commit_user_email: 41898282+github-actions[bot]@users.noreply.github.com
          push_options: --force-with-lease
          skip_fetch: false

      # Create and push tag to trigger deploy workflow
      # Using git commands instead of API to ensure deploy workflow triggers
      - name: Create and push tag
        if: steps.bump.outputs.version != '' && steps.commit.outputs.commit_hash != ''
        shell: bash
        run: |
          VERSION="${{ steps.bump.outputs.version }}"
          TAG="v${VERSION}"
          SHA="${{ steps.commit.outputs.commit_hash }}"

          # Check if tag already exists
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists"
            exit 0
          fi

          # Create and push the tag
          git tag "$TAG" "$SHA"
          git push origin "$TAG" || {
            # Tag might have been created by another workflow run (race condition)
            echo "Tag $TAG could not be pushed (may already exist remotely)"
            exit 0
          }

      # Open or reuse PR from release/vX.Y.Z (aka release/v${version}) into main
      - name: Create release branch and PR for tag
        if: steps.bump.outputs.version != '' && steps.commit.outputs.commit_hash != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const version = '${{ steps.bump.outputs.version }}';
            const tag = `v${version}`;
            const branch = `release/${tag}`;
            const sha = '${{ steps.commit.outputs.commit_hash || github.sha }}';

            // 1) Ensure the branch exists at the tag's commit (idempotent)
            async function ensureBranch() {
              try {
                await github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` });
                core.info(`Branch ${branch} already exists`);
              } catch (err) {
                if (err.status !== 404) throw err;
                await github.rest.git.createRef({
                  owner, repo,
                  ref: `refs/heads/${branch}`,
                  sha
                });
                core.info(`Created branch ${branch} at ${sha}`);
              }
            }

            // 2) Generate release notes (best-effort)
            async function generateNotes() {
              try {
                const { data } = await github.rest.repos.generateReleaseNotes({
                  owner, repo,
                  tag_name: tag,
                  target_commitish: sha
                });
                return data.body || `Release ${tag}`;
              } catch (e) {
                core.warning(`Could not generate notes: ${e.message}`);
                return `Release ${tag}`;
              }
            }

            // 3) Create (or reuse) PR release/<tag> -> main
            async function ensurePullRequest(body) {
              const baseBranch = 'main';
              const headBranch = branch;

              const { data: prs } = await github.rest.pulls.list({
                owner, repo, state: 'open', head: `${owner}:${headBranch}`, base: baseBranch
              });

              if (prs.length > 0) {
                core.info(`PR already exists: #${prs[0].number}`);
                core.setOutput('pr_number', prs[0].number);
                return;
              }

              const { data: pr } = await github.rest.pulls.create({
                owner, repo,
                title: `Release ${tag}`,
                head: headBranch,
                base: baseBranch,
                body
              });
              core.info(`Created PR #${pr.number} for ${headBranch} -> ${baseBranch}`);
              core.setOutput('pr_number', pr.number);
            }

            await ensureBranch();
            const body = await generateNotes();
            await ensurePullRequest(body)
